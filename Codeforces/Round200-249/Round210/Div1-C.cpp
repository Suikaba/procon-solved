#include <bits/stdc++.h>
using namespace std;

// 解法
// 普通に dp[i][j] := i 番目までみて、substring の個数が j 個であるような場合の数
// としたいけど、遷移ができない。
// そもそも、dp テーブル考える前に文字列の増え方を観察しなければならない（当たり前なんだよね。
// 構築途中の文字列を t とおく。今 i 番目をみているとして (1) s[i] < t[i], (2) s[i] == t[i], (3) s[i] > t[i]
// を考えよう。考えるのは、i 番目を左端とする部分文字列の総数である。
// (1) s[i] < t[i]
//    t[i..] はこの時点で全部条件を満たす部分文字列となり、その総数は n - i 個である。
// (2) s[i] == t[i]
//    今後の t に依存する。i 以降ではじめて s[j] != t[j] となる位置を j とおく。
//    もし s[j] > t[j] であれば、0 とおりである。
//    もし s[j] < t[j] であれば、左端が i で条件を満たす部分文字列は (n - j) 通りになる。
// (3) s[i] > t[i]
//    これを左端とする部分文字列は存在しないので 0 通り。
// さて、(2) をもう少し dp 遷移のことも考えて言い換えてみる。s[i] == t[i] の場合を、s[j] < t[j] 視点で考え直す。
// s[j] < t[j] のとき、j から前の方向に連続して s[k] == t[k] となる最大長さを p とする。
// すると、s[j] < t[j] によって、新たに (p + 1) * (n - j) 通りの条件を見たす部分文字列が確定する。
// これで、(2) は事実上 (1) とまとめて考えることができるようになった。
//
// これを踏まえて、dp テーブルを考える。
// dp[i][j] := (最初に述べたもの)
// は、観察における「はじめて s[j] != t[j] となる～」の情報がないので、うまく遷移を構築できない。
// よって
// dp[i][ss] := i 番目までみて、「現時点で確定した」部分文字列が ss 個であり、かつ s[i] != t[i] を満たすものの総数
// と定義する。
// すると、遷移は以下のようになる。
// (1)(2)
//    dp[i + 1][ss] += dp[i - p][sum - (p + 1) * (n - i)] * ('z' - s[i]) (p = 0, 1, ...)
// (3)
//    dp[i + 1][ss] += dp[i - p][sum] * (s[i] - 'a') (p = 0, 1, ...)
// 計算量について議論しよう。
// まず (3) は累積和によってオーダーが落とせるので、O(nk) となる。
// (1)(2) についてだが、p がどれぐらい回るかを考える。sum - (p + 1) * (n - i) >= 0 である必要があり、
// sum <= k なので、k - (p + 1) * (n - i) >= 0 すなわち p <= k / (n - i) であり、各 i について高々 k / (n - i) 回である。
// これを全ての i, ss について足すと
//     k * sum(k / (n - i)) (i = 0, 1, ..., n - 1)
//   = k * sum(k / i) (i = 1, ..., n)
//   < k * (n + klogk)
// となり、間に合うことがわかる。

// 感想
// まず遷移が難しいのにオーダー解析も必要なのでかなり難しい。
// 実装は簡単。

using ll = long long;

constexpr int mod = 1e9 + 7;

int main() {
    int n, k; cin >> n >> k;
    string s; cin >> s;

    vector<vector<ll>> dp(n + 1, vector<ll>(k + 1));
    vector<ll> sum(k + 1); // dp[0][x] + dp[1][x] + ...
    dp[0][0] = 1;
    sum[0] = 1;
    for(int i = 0; i < n; ++i) {
        for(int ss = 0; ss <= k; ++ss) { // substring count
            // t[i] < s[i]
            (dp[i + 1][ss] += sum[ss] * (s[i] - 'a')) %= mod;
            // t[i] > s[i]
            for(int p = 0; i - p >= 0 && ss - (p + 1) * (n - i) >= 0; ++p) { // how many last s[l] == t[l] ? (l = i - 1, i - 2, ...)
                (dp[i + 1][ss] += dp[i - p][ss - (p + 1) * (n - i)] * ('z' - s[i])) %= mod;
            }
            (sum[ss] += dp[i + 1][ss]) %= mod;
        }
    }

    int ans = 0;
    for(int i = 0; i <= n; ++i) {
        (ans += dp[i][k]) %= mod;
    }
    cout << ans << endl;
}
