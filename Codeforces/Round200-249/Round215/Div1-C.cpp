
// https://codeforces.com/contest/367/problem/C

// 解法
// 結局考えるべきことは、n 頂点のグラフで、任意の2頂点が隣接しており、
// かつオイラー路（閉路でなくて良い）が存在するようなグラフの最小の辺の数はいくつか？
// ということである。完全グラフではない場合がある（試しにやってみればわかる）ことに注意。
// n が奇数のとき、任意の頂点の次数は偶数だから、オイラー閉路が存在するため、n * (n - 1) / 2 個が最小である。
// n が偶数のとき、すべての頂点の次数は奇数である。オイラー路が存在するためには、少なくとも準オイラー的である必要がある。
// つまり、n 頂点のうち n - 2 頂点の次数を偶数にする必要があり、それはつまり、(n - 2) / 2 = n/2 - 1 本の追加の辺が必要という意味。
// これで最小の辺の数は求まったから、（辺の数） <= n を満たす最小の整数を求めて、その分だけコストの小さいものから貪欲に取ればよい。
// m との min を取るのを忘れないように。

#include <bits/stdc++.h>
using namespace std;

using ll = long long;

int main() {
    int n, m; cin >> n >> m;
    vector<int> q(m), w(m);
    for(int i = 0; i < m; ++i) {
        cin >> q[i] >> w[i];
    }
    sort(rbegin(w), rend(w));

    int k = 1;
    while(k * (k + 1) / 2 + 1 + (k & 1 ? (k + 1) / 2 - 1 : 0) <= n) k++;
    k = min(m, k);

    cout << accumulate(begin(w), begin(w) + k, 0LL) << endl;
}
